#lang scheme


; алгоритм
; на каждом шаге решаем, брать ли текущий элемент последовательности или нет
;   -   если берем, то запускаем рекурсивно процедуру для оставщейся части, 
;       отнимая количество оставшихся свободных мест (- k 1)
;       а к результату прибавляем текущий элемент
;   -   если не берем, то запускам прицедуру рекурсивно для остащейся части 
;       не отнимая количество оставщихся сводобных мест
; результат - пересечение этих двух множест 

(define (c k seq)
    (cond
        ((= k 0) '(()))
        ((null? seq) '())
        (else
            (let
                ((head (car seq))
                 (tail (cdr seq)))
                (append
                    (map (lambda (comb) (cons head comb)) (c (- k 1) tail))
                    (c k tail)
                )
            )
        )
    )
)


(c 3 '(1 2 3 4 5))